This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-10-19T11:48:38.033Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
cmd/api/main.go
docker-compose.yml
Dockerfile
Dockerfile.test
go.mod
internal/api/handlers/contact_handler.go
internal/api/handlers/hotel_handler.go
internal/api/handlers/report_handler.go
internal/api/middleware/logging.go
internal/api/router.go
internal/config/config.go
internal/db/db.go
internal/db/migrations.go
internal/db/migrations/000001_create_hotels_table.up.sql
internal/db/migrations/000002_create_contacts_table.up.sql
internal/messaging/rabbitmq.go
internal/models/contact.go
internal/models/hotel.go
internal/repository/contact_repository.go
internal/repository/hotel_repository.go
internal/service/contact_service.go
internal/service/hotel_service.go
logstash/pipeline/logstash.conf
pkg/logger/logger.go
README.md
tests/integration/rabbitmq_test.go
tests/unit/handlers_test.go
tests/unit/rabbitmq_test.go
tests/unit/repositories_test.go
tests/unit/services_test.go

================================================================
Repository Files
================================================================

================
File: cmd/api/main.go
================
package main

import (
	"log"
	"net/http"

	"github.com/olivere/elastic/v7"
	"github.com/tfgoztok/hotel-service/internal/api"
	"github.com/tfgoztok/hotel-service/internal/config"
	"github.com/tfgoztok/hotel-service/internal/db"
	"github.com/tfgoztok/hotel-service/internal/messaging"
	"github.com/tfgoztok/hotel-service/pkg/logger"
)

func main() {
	cfg, err := config.Load()
	if err != nil {
		log.Fatalf("Failed to load config: %v", err)
	}

	logger := logger.New()

	database, err := db.Connect(cfg.DatabaseURL)
	if err != nil {
		logger.Fatal("Failed to connect to database", "error", err)
	}
	defer database.Close()

	rabbitMQ, err := messaging.NewRabbitMQ(cfg.RabbitMQURL)
	if err != nil {
		logger.Fatal("Failed to connect to RabbitMQ", "error", err)
	}
	defer rabbitMQ.Close()

	// Connect to Elasticsearch
	esClient, err := elastic.NewClient(
		elastic.SetURL(cfg.ElasticsearchURL),
		elastic.SetSniff(false),
	)
	if err != nil {
		logger.Fatal("Failed to connect to Elasticsearch", "error", err)
	}

	// Run migrations
	if err := db.RunMigrations(database, "./internal/db/migrations"); err != nil {
		logger.Fatal("Failed to run migrations", "error", err)
	}

	router := api.NewRouter(database, logger, rabbitMQ, esClient)

	logger.Info("Starting server", "port", cfg.Port)
	if err := http.ListenAndServe(":"+cfg.Port, router); err != nil {
		logger.Fatal("Server failed to start", "error", err)
	}
}

================
File: docker-compose.yml
================
version: '2.4'

services:
  app:
    build: .
    ports:
      - "8080:8080"
    environment:
      - DATABASE_URL=postgres://user:password@db:5432/hoteldb?sslmode=disable
      - RABBITMQ_URL=amqp://guest:guest@rabbitmq:5672/
      - ELASTICSEARCH_URL=http://elasticsearch:9200
    depends_on:
      db:
        condition: service_healthy
      rabbitmq:
        condition: service_healthy
      elasticsearch:
        condition: service_healthy
    logging:
      driver: "json-file"
      options:
        max-size: "200k"
        max-file: "10"

  test:
    build:
      context: .
      dockerfile: Dockerfile.test
    environment:
      - DATABASE_URL=postgres://user:password@db:5432/hoteldb?sslmode=disable
      - RABBITMQ_URL=amqp://guest:guest@rabbitmq:5672/
    depends_on:
      db:
        condition: service_healthy
      rabbitmq:
        condition: service_healthy
    command: ["go", "test", "./tests/...", "-v", "-cover"]

  db:
    image: postgres:13.4-alpine
    environment:
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
      POSTGRES_DB: hoteldb
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U user -d hoteldb"]
      interval: 10s
      timeout: 5s
      retries: 5

  rabbitmq:
    image: rabbitmq:3-alpine
    ports:
      - "5672:5672"
      - "15672:15672"
    healthcheck:
      test: ["CMD", "rabbitmq-diagnostics", "check_port_connectivity"]
      interval: 10s
      timeout: 5s
      retries: 10

  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:7.15.0
    environment:
      - discovery.type=single-node
      - "ES_JAVA_OPTS=-Xms512m -Xmx512m"
    ports:
      - "9200:9200"
    healthcheck:
      test: ["CMD-SHELL", "curl -s http://localhost:9200 >/dev/null || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 5

  logstash:
    image: docker.elastic.co/logstash/logstash:7.15.0
    volumes:
      - ./logstash/pipeline:/usr/share/logstash/pipeline:ro
    ports:
      - "5044:5044"
    depends_on:
      elasticsearch:
        condition: service_healthy
    environment:
      - "LS_JAVA_OPTS=-Xms256m -Xmx256m"

  kibana:
    image: docker.elastic.co/kibana/kibana:7.15.0
    ports:
      - "5601:5601"
    environment:
      ELASTICSEARCH_URL: http://elasticsearch:9200
      ELASTICSEARCH_HOSTS: '["http://elasticsearch:9200"]'
    depends_on:
      elasticsearch:
        condition: service_healthy

================
File: Dockerfile
================
FROM golang:1.21-alpine AS builder

WORKDIR /app

COPY go.mod go.sum ./
RUN go mod download

COPY . .

RUN CGO_ENABLED=0 GOOS=linux go build -o /hotel-service ./cmd/api

FROM alpine:3.14

WORKDIR /

COPY --from=builder /hotel-service /hotel-service
COPY --from=builder /app/internal/db/migrations /internal/db/migrations

# Copy test files
COPY --from=builder /app/tests /tests

EXPOSE 8080

CMD ["/hotel-service"]

================
File: Dockerfile.test
================
FROM golang:1.21-alpine

WORKDIR /app

COPY go.mod go.sum ./
RUN go mod download

COPY . .

# Wait for RabbitMQ to be ready
CMD ["sh", "-c", "apk add --no-cache netcat-openbsd && while ! nc -z rabbitmq 5672; do sleep 1; done; go test ./tests/... -v -cover"]

================
File: go.mod
================
module github.com/tfgoztok/hotel-service

go 1.21.1

require (
	github.com/DATA-DOG/go-sqlmock v1.5.0
	github.com/golang-migrate/migrate/v4 v4.15.2
	github.com/google/uuid v1.3.0
	github.com/gorilla/mux v1.8.0
	github.com/lib/pq v1.10.9
	github.com/olivere/elastic/v7 v7.0.32
	github.com/spf13/viper v1.15.0
	github.com/streadway/amqp v1.0.0
	github.com/stretchr/testify v1.8.1
)

require (
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/fsnotify/fsnotify v1.6.0 // indirect
	github.com/hashicorp/errwrap v1.1.0 // indirect
	github.com/hashicorp/go-multierror v1.1.1 // indirect
	github.com/hashicorp/hcl v1.0.0 // indirect
	github.com/josharian/intern v1.0.0 // indirect
	github.com/magiconair/properties v1.8.7 // indirect
	github.com/mailru/easyjson v0.7.7 // indirect
	github.com/mitchellh/mapstructure v1.5.0 // indirect
	github.com/pelletier/go-toml/v2 v2.0.6 // indirect
	github.com/pkg/errors v0.9.1 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/spf13/afero v1.9.3 // indirect
	github.com/spf13/cast v1.5.0 // indirect
	github.com/spf13/jwalterweatherman v1.1.0 // indirect
	github.com/spf13/pflag v1.0.5 // indirect
	github.com/subosito/gotenv v1.4.2 // indirect
	go.uber.org/atomic v1.9.0 // indirect
	golang.org/x/sys v0.3.0 // indirect
	golang.org/x/text v0.5.0 // indirect
	gopkg.in/ini.v1 v1.67.0 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)

================
File: internal/api/handlers/contact_handler.go
================
package handlers

import (
	"encoding/json"
	"net/http"

	"github.com/google/uuid"
	"github.com/gorilla/mux"
	"github.com/tfgoztok/hotel-service/internal/models"
	"github.com/tfgoztok/hotel-service/internal/service"
)

type ContactHandler struct {
	service *service.ContactService // Service for handling contact operations
}

func NewContactHandler(service *service.ContactService) *ContactHandler {
	return &ContactHandler{service: service} // Constructor for ContactHandler
}

func (h *ContactHandler) AddContact(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)                    // Get URL parameters
	hotelID, err := uuid.Parse(params["id"]) // Parse hotel ID from parameters
	if err != nil {
		http.Error(w, "Invalid hotel ID", http.StatusBadRequest) // Handle invalid hotel ID
		return
	}

	var contact models.Contact // Create a new contact instance
	if err := json.NewDecoder(r.Body).Decode(&contact); err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest) // Handle JSON decoding errors
		return
	}
	contact.HotelID = hotelID // Associate the contact with the hotel ID

	if err := h.service.AddContact(r.Context(), &contact); err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError) // Handle service errors
		return
	}

	w.WriteHeader(http.StatusCreated)  // Respond with 201 Created
	json.NewEncoder(w).Encode(contact) // Return the created contact
}

func (h *ContactHandler) DeleteContact(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)                             // Get URL parameters
	contactID, err := uuid.Parse(params["contactId"]) // Parse contact ID from parameters
	if err != nil {
		http.Error(w, "Invalid contact ID", http.StatusBadRequest) // Handle invalid contact ID
		return
	}

	if err := h.service.DeleteContact(r.Context(), contactID); err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError) // Handle service errors
		return
	}

	w.WriteHeader(http.StatusNoContent) // Respond with 204 No Content
}

================
File: internal/api/handlers/hotel_handler.go
================
package handlers

import (
	"encoding/json"
	"net/http"

	"github.com/google/uuid"
	"github.com/gorilla/mux"
	"github.com/tfgoztok/hotel-service/internal/models"
	"github.com/tfgoztok/hotel-service/internal/service"
)

// HotelHandler handles hotel-related HTTP requests
type HotelHandler struct {
	service *service.HotelService // Service for hotel operations
}

// NewHotelHandler creates a new HotelHandler with the given service
func NewHotelHandler(service *service.HotelService) *HotelHandler {
	return &HotelHandler{service: service}
}

// CreateHotel handles the creation of a new hotel
func (h *HotelHandler) CreateHotel(w http.ResponseWriter, r *http.Request) {
	var hotel models.Hotel
	// Decode the incoming JSON request body into the hotel struct
	if err := json.NewDecoder(r.Body).Decode(&hotel); err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest) // Return error if decoding fails
		return
	}

	// Call the service to create the hotel
	if err := h.service.CreateHotel(r.Context(), &hotel); err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError) // Return error if creation fails
		return
	}

	w.WriteHeader(http.StatusCreated) // Respond with 201 Created
	json.NewEncoder(w).Encode(hotel)  // Return the created hotel as JSON
}

// DeleteHotel handles the deletion of a hotel by ID
func (h *HotelHandler) DeleteHotel(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)               // Get URL parameters
	id, err := uuid.Parse(params["id"]) // Parse the hotel ID from parameters
	if err != nil {
		http.Error(w, "Invalid hotel ID", http.StatusBadRequest) // Return error if ID is invalid
		return
	}

	// Call the service to delete the hotel
	if err := h.service.DeleteHotel(r.Context(), id); err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError) // Return error if deletion fails
		return
	}

	w.WriteHeader(http.StatusNoContent) // Respond with 204 No Content
}

// GetHotelDetails retrieves the details of a hotel by ID
func (h *HotelHandler) GetHotelDetails(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	id, err := uuid.Parse(params["id"])
	if err != nil {
		http.Error(w, "Invalid hotel ID", http.StatusBadRequest)
		return
	}

	hotel, err := h.service.GetHotelDetails(r.Context(), id)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	json.NewEncoder(w).Encode(hotel)
}

// ListOfficials lists the officials of a hotel by ID.
func (h *HotelHandler) ListOfficials(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	id, err := uuid.Parse(params["id"])
	if err != nil {
		http.Error(w, "Invalid hotel ID", http.StatusBadRequest)
		return
	}

	officials, err := h.service.ListOfficials(r.Context(), id)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	json.NewEncoder(w).Encode(officials)
}

================
File: internal/api/handlers/report_handler.go
================
package handlers

import (
	"encoding/json"
	"net/http"

	"github.com/google/uuid"
	"github.com/olivere/elastic/v7"
	"github.com/tfgoztok/hotel-service/internal/messaging"
)

type ReportHandler struct {
	rabbitMQ messaging.RabbitMQInterface
	esClient *elastic.Client
}

func NewReportHandler(rabbitMQ messaging.RabbitMQInterface, esClient *elastic.Client) *ReportHandler {
	return &ReportHandler{rabbitMQ: rabbitMQ, esClient: esClient}
}

type ReportRequest struct {
	ID     uuid.UUID `json:"id"`
	Status string    `json:"status"`
}

func (h *ReportHandler) RequestReport(w http.ResponseWriter, r *http.Request) {
	// Create a new report request with a unique ID and a status of "pending"
	reportRequest := ReportRequest{
		ID:     uuid.New(),
		Status: "pending",
	}

	// Publish the report request to the RabbitMQ queue
	err := h.rabbitMQ.PublishReportRequest("report_requests", reportRequest)
	if err != nil {
		// If publishing fails, return an internal server error
		http.Error(w, "Failed to request report", http.StatusInternalServerError)
		return
	}

	// Index the report request in Elasticsearch
	_, err = h.esClient.Index().
		Index("report_requests").
		Id(reportRequest.ID.String()).
		BodyJson(reportRequest).
		Do(r.Context())
	if err != nil {
		// If indexing fails, return an internal server error
		http.Error(w, "Failed to index report request", http.StatusInternalServerError)
		return
	}

	// Respond with a 202 Accepted status and encode the report request in the response
	w.WriteHeader(http.StatusAccepted)
	json.NewEncoder(w).Encode(reportRequest)
}

================
File: internal/api/middleware/logging.go
================
package middleware

import (
	"net/http"
	"time"

	"github.com/tfgoztok/hotel-service/pkg/logger"
)

// Logging is a middleware function that logs HTTP requests.
func Logging(l logger.Logger) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		// Return an http.HandlerFunc to handle the request
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			start := time.Now()  // Record the start time of the request
			next.ServeHTTP(w, r) // Call the next handler in the chain
			// Log the request details including method, path, and duration
			l.Info("Request processed",
				"method", r.Method,
				"path", r.URL.Path,
				"duration", time.Since(start),
			)
		})
	}
}

================
File: internal/api/router.go
================
package api

import (
	"database/sql"
	"net/http"

	"github.com/gorilla/mux"
	"github.com/olivere/elastic/v7"
	"github.com/tfgoztok/hotel-service/internal/api/handlers"
	"github.com/tfgoztok/hotel-service/internal/api/middleware"
	"github.com/tfgoztok/hotel-service/internal/messaging"
	"github.com/tfgoztok/hotel-service/internal/repository"
	"github.com/tfgoztok/hotel-service/internal/service"
	"github.com/tfgoztok/hotel-service/pkg/logger"
)

func NewRouter(db *sql.DB, logger logger.Logger, rabbitMQ messaging.RabbitMQInterface, esClient *elastic.Client) http.Handler {
	// Create a new router instance
	r := mux.NewRouter()

	// Initialize repositories for hotels and contacts
	hotelRepo := repository.NewHotelRepository(db)
	contactRepo := repository.NewContactRepository(db)

	// Initialize services for hotels and contacts
	hotelService := service.NewHotelService(hotelRepo)
	contactService := service.NewContactService(contactRepo)

	// Initialize handlers for hotels and contacts
	hotelHandler := handlers.NewHotelHandler(hotelService)
	contactHandler := handlers.NewContactHandler(contactService)

	// Initialize handler for elk
	reportHandler := handlers.NewReportHandler(rabbitMQ, esClient)

	// Middleware for logging requests
	r.Use(middleware.Logging(logger))

	// Define routes for hotel operations
	r.HandleFunc("/hotels", hotelHandler.CreateHotel).Methods("POST")                                 // Create a new hotel
	r.HandleFunc("/hotels/{id}", hotelHandler.DeleteHotel).Methods("DELETE")                          // Delete a hotel by ID
	r.HandleFunc("/hotels/{id}/contacts", contactHandler.AddContact).Methods("POST")                  // Add a contact to a hotel
	r.HandleFunc("/hotels/{id}/contacts/{contactId}", contactHandler.DeleteContact).Methods("DELETE") // Delete a contact by ID
	r.HandleFunc("/hotels/{id}/officials", hotelHandler.ListOfficials).Methods("GET")                 // List officials for a hotel
	r.HandleFunc("/hotels/{id}", hotelHandler.GetHotelDetails).Methods("GET")                         // Get details of a hotel
	r.HandleFunc("/reports/request", reportHandler.RequestReport).Methods("POST")                     // Request report from report-service

	return r // Return the configured router
}

================
File: internal/config/config.go
================
package config

import (
	"github.com/spf13/viper"
)

// Config struct holds the configuration values for the application.
type Config struct {
	Port             string `mapstructure:"PORT"`              // Port for the application
	DatabaseURL      string `mapstructure:"DATABASE_URL"`      // Database connection URL
	LogLevel         string `mapstructure:"LOG_LEVEL"`         // Logging level for the application
	RabbitMQURL      string `mapstructure:"RABBITMQ_URL"`      // RabbitMQ connection URL
	ElasticsearchURL string `mapstructure:"ELASTICSEARCH_URL"` // Elasticsearch connection URL
}

// Load function initializes the configuration by reading environment variables and setting defaults.
func Load() (*Config, error) {
	viper.AutomaticEnv() // Automatically read environment variables

	// Set default values for configuration
	viper.SetDefault("PORT", "8080")                                                                    // Default port
	viper.SetDefault("DATABASE_URL", "postgres://user:password@localhost:5432/hoteldb?sslmode=disable") // Default database URL
	viper.SetDefault("LOG_LEVEL", "info")                                                               // Default log level
	viper.SetDefault("RABBITMQ_URL", "amqp://guest:guest@localhost:5672/")                              // Default Rabbitmq URL
	viper.SetDefault("ELASTICSEARCH_URL", "http://localhost:9200")

	var config Config                                // Create an instance of Config to hold the values
	if err := viper.Unmarshal(&config); err != nil { // Unmarshal environment variables into the config struct
		return nil, err // Return nil and the error if unmarshalling fails
	}

	return &config, nil // Return the populated config struct and nil error
}

================
File: internal/db/db.go
================
package db

import (
	"database/sql"
	_ "github.com/lib/pq"
)

func Connect(databaseURL string) (*sql.DB, error) {
	// Attempt to open a connection to the database using the provided URL
	db, err := sql.Open("postgres", databaseURL)
	if err != nil {
		// Return nil and the error if the connection could not be established
		return nil, err
	}

	// Ping the database to verify that the connection is alive
	if err := db.Ping(); err != nil {
		// Return nil and the error if the ping fails
		return nil, err
	}

	// Return the database connection if successful
	return db, nil
}

================
File: internal/db/migrations.go
================
package db

import (
	"database/sql"
	"fmt"

	"github.com/golang-migrate/migrate/v4"
	"github.com/golang-migrate/migrate/v4/database/postgres"
	_ "github.com/golang-migrate/migrate/v4/source/file"
)

// RunMigrations executes the database migrations from the specified path.
func RunMigrations(db *sql.DB, migrationPath string) error {
	// Create a new Postgres driver instance using the provided database connection.
	driver, err := postgres.WithInstance(db, &postgres.Config{})
	if err != nil {
		return fmt.Errorf("could not create the postgres driver: %v", err)
	}

	// Create a new migration instance with the specified migration path and database driver.
	m, err := migrate.NewWithDatabaseInstance(
		"file://"+migrationPath,
		"postgres", driver)
	if err != nil {
		return fmt.Errorf("could not create the migration instance: %v", err)
	}

	// Run the migrations. If there are no changes, it will not return an error.
	if err := m.Up(); err != nil && err != migrate.ErrNoChange {
		return fmt.Errorf("could not run up migrations: %v", err)
	}

	// Return nil if migrations were successful or if there were no changes.
	return nil
}

================
File: internal/db/migrations/000001_create_hotels_table.up.sql
================
CREATE TABLE IF NOT EXISTS hotels (
    id UUID PRIMARY KEY,
    official_name VARCHAR(100) NOT NULL,
    official_surname VARCHAR(100) NOT NULL,
    company_title VARCHAR(200) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

================
File: internal/db/migrations/000002_create_contacts_table.up.sql
================
CREATE TABLE IF NOT EXISTS contacts (
    id UUID PRIMARY KEY,
    hotel_id UUID REFERENCES hotels(id) ON DELETE CASCADE,
    type VARCHAR(20) NOT NULL,
    content TEXT NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

================
File: internal/messaging/rabbitmq.go
================
package messaging

import (
	"encoding/json"
	"fmt"

	"github.com/streadway/amqp"
)

// RabbitMQInterface defines the methods that our RabbitMQ implementation should have
type RabbitMQInterface interface {
	PublishReportRequest(queueName string, reportRequest interface{}) error
	Close()
}

// RabbitMQ struct implements the RabbitMQInterface
type RabbitMQ struct {
	conn    *amqp.Connection
	channel *amqp.Channel
}

// NewRabbitMQ creates a new RabbitMQ instance
func NewRabbitMQ(url string) (RabbitMQInterface, error) {
	conn, err := amqp.Dial(url)
	if err != nil {
		return nil, fmt.Errorf("failed to connect to RabbitMQ: %v", err)
	}

	ch, err := conn.Channel()
	if err != nil {
		return nil, fmt.Errorf("failed to open a channel: %v", err)
	}

	return &RabbitMQ{conn: conn, channel: ch}, nil
}

// PublishReportRequest publishes a report request to the specified queue
func (r *RabbitMQ) PublishReportRequest(queueName string, reportRequest interface{}) error {
	q, err := r.channel.QueueDeclare(
		queueName,
		false,
		false,
		false,
		false,
		nil,
	)
	if err != nil {
		return fmt.Errorf("failed to declare a queue: %v", err)
	}

	body, err := json.Marshal(reportRequest)
	if err != nil {
		return fmt.Errorf("failed to marshal report request: %v", err)
	}

	err = r.channel.Publish(
		"",
		q.Name,
		false,
		false,
		amqp.Publishing{
			ContentType: "application/json",
			Body:        body,
		})
	if err != nil {
		return fmt.Errorf("failed to publish a message: %v", err)
	}

	return nil
}

// Close closes the RabbitMQ connection and channel
func (r *RabbitMQ) Close() {
	if r.channel != nil {
		r.channel.Close()
	}
	if r.conn != nil {
		r.conn.Close()
	}
}

================
File: internal/models/contact.go
================
package models

import (
	"time"

	"github.com/google/uuid"
)

type Contact struct {
	ID        uuid.UUID `json:"id"`
	HotelID   uuid.UUID `json:"hotel_id"`
	Type      string    `json:"type"`
	Content   string    `json:"content"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

================
File: internal/models/hotel.go
================
package models

import (
	"time"

	"github.com/google/uuid"
)

type Hotel struct {
	ID              uuid.UUID `json:"id"`
	OfficialName    string    `json:"official_name"`
	OfficialSurname string    `json:"official_surname"`
	CompanyTitle    string    `json:"company_title"`
	CreatedAt       time.Time `json:"created_at"`
	UpdatedAt       time.Time `json:"updated_at"`
}

type HotelOfficials struct {
	HotelID         uuid.UUID `json:"hotel_id"`
	OfficialName    string    `json:"official_name"`
	OfficialSurname string    `json:"official_surname"`
}

================
File: internal/repository/contact_repository.go
================
package repository

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/tfgoztok/hotel-service/internal/models"
)

// ContactRepository is a struct that holds the database connection.
type ContactRepository struct {
	db *sql.DB // Database connection
}

// NewContactRepository initializes a new ContactRepository with the provided database connection.
func NewContactRepository(db *sql.DB) *ContactRepository {
	return &ContactRepository{db: db}
}

// Create inserts a new contact into the database.
// It takes a context for managing request-scoped values and a pointer to a Contact model.
func (r *ContactRepository) Create(ctx context.Context, contact *models.Contact) error {
	query := `
		INSERT INTO contacts (id, hotel_id, type, content, created_at, updated_at)
		VALUES ($1, $2, $3, $4, $5, $6)
	`
	// Execute the insert query with the contact's details.
	_, err := r.db.ExecContext(ctx, query, contact.ID, contact.HotelID, contact.Type, contact.Content, contact.CreatedAt, contact.UpdatedAt)
	return err // Return any error encountered during execution.
}

// Delete removes a contact from the database by its ID.
// It takes a context and the UUID of the contact to be deleted.
func (r *ContactRepository) Delete(ctx context.Context, id uuid.UUID) error {
	query := `DELETE FROM contacts WHERE id = $1`
	// Execute the delete query using the provided contact ID.
	_, err := r.db.ExecContext(ctx, query, id)
	return err // Return any error encountered during execution.
}

// GetByHotelID retrieves all contacts associated with a specific hotel ID.
// It returns a slice of pointers to Contact models and an error if any occurs.
func (r *ContactRepository) GetByHotelID(ctx context.Context, hotelID uuid.UUID) ([]*models.Contact, error) {
	query := `
		SELECT id, hotel_id, type, content, created_at, updated_at
		FROM contacts
		WHERE hotel_id = $1
	`
	// Execute the query to fetch contacts for the specified hotel ID.
	rows, err := r.db.QueryContext(ctx, query, hotelID)
	if err != nil {
		return nil, err // Return nil and the error if the query fails.
	}
	defer rows.Close() // Ensure rows are closed after processing.

	var contacts []*models.Contact // Slice to hold the retrieved contacts.
	for rows.Next() {
		var contact models.Contact // Temporary variable to hold each contact.
		// Scan the row into the contact variable.
		err := rows.Scan(&contact.ID, &contact.HotelID, &contact.Type, &contact.Content, &contact.CreatedAt, &contact.UpdatedAt)
		if err != nil {
			return nil, err // Return nil and the error if scanning fails.
		}
		contacts = append(contacts, &contact) // Append the contact to the slice.
	}
	return contacts, nil // Return the slice of contacts and nil for no error.
}

================
File: internal/repository/hotel_repository.go
================
package repository

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/tfgoztok/hotel-service/internal/models"
)

// HotelRepository is a struct that holds the database connection.
type HotelRepository struct {
	db *sql.DB // Database connection
}

// NewHotelRepository initializes a new HotelRepository with the provided database connection.
func NewHotelRepository(db *sql.DB) *HotelRepository {
	return &HotelRepository{db: db} // Return a new instance of HotelRepository
}

// Create inserts a new hotel record into the database.
func (r *HotelRepository) Create(ctx context.Context, hotel *models.Hotel) error {
	query := `
		INSERT INTO hotels (id, official_name, official_surname, company_title, created_at, updated_at)
		VALUES ($1, $2, $3, $4, $5, $6)
	`
	// Execute the insert query with hotel details
	_, err := r.db.ExecContext(ctx, query, hotel.ID, hotel.OfficialName, hotel.OfficialSurname, hotel.CompanyTitle, hotel.CreatedAt, hotel.UpdatedAt)
	return err // Return any error encountered
}

// Delete removes a hotel record from the database by its ID.
func (r *HotelRepository) Delete(ctx context.Context, id uuid.UUID) error {
	query := `DELETE FROM hotels WHERE id = $1`
	// Execute the delete query using the hotel ID
	_, err := r.db.ExecContext(ctx, query, id)
	return err // Return any error encountered
}

// GetByID retrieves a hotel record from the database by its ID.
func (r *HotelRepository) GetByID(ctx context.Context, id uuid.UUID) (*models.Hotel, error) {
	query := `
		SELECT id, official_name, official_surname, company_title, created_at, updated_at
		FROM hotels
		WHERE id = $1
	`
	var hotel models.Hotel // Variable to hold the retrieved hotel
	// Execute the select query and scan the result into the hotel variable
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&hotel.ID, &hotel.OfficialName, &hotel.OfficialSurname, &hotel.CompanyTitle, &hotel.CreatedAt, &hotel.UpdatedAt,
	)
	if err != nil {
		return nil, err // Return nil and the error if something went wrong
	}
	return &hotel, nil // Return the retrieved hotel
}

================
File: internal/service/contact_service.go
================
package service

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/tfgoztok/hotel-service/internal/models"
	"github.com/tfgoztok/hotel-service/internal/repository"
)

// ContactService provides methods to manage contacts.
type ContactService struct {
	repo *repository.ContactRepository // Repository for contact data
}

// NewContactService creates a new instance of ContactService.
func NewContactService(repo *repository.ContactRepository) *ContactService {
	return &ContactService{repo: repo} // Initialize ContactService with the provided repository
}

// AddContact adds a new contact to the repository.
func (s *ContactService) AddContact(ctx context.Context, contact *models.Contact) error {
	contact.ID = uuid.New()            // Generate a new unique ID for the contact
	contact.CreatedAt = time.Now()     // Set the creation timestamp
	contact.UpdatedAt = time.Now()     // Set the updated timestamp
	return s.repo.Create(ctx, contact) // Save the contact to the repository
}

// DeleteContact removes a contact from the repository by its ID.
func (s *ContactService) DeleteContact(ctx context.Context, id uuid.UUID) error {
	return s.repo.Delete(ctx, id) // Call the repository to delete the contact
}

// GetContactsByHotelID retrieves all contacts associated with a specific hotel ID.
func (s *ContactService) GetContactsByHotelID(ctx context.Context, hotelID uuid.UUID) ([]*models.Contact, error) {
	return s.repo.GetByHotelID(ctx, hotelID) // Fetch contacts from the repository by hotel ID
}

================
File: internal/service/hotel_service.go
================
package service

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/tfgoztok/hotel-service/internal/models"
	"github.com/tfgoztok/hotel-service/internal/repository"
)

// HotelService provides methods to manage hotels.
type HotelService struct {
	repo *repository.HotelRepository // Repository for hotel data
}

// NewHotelService creates a new instance of HotelService.
func NewHotelService(repo *repository.HotelRepository) *HotelService {
	return &HotelService{repo: repo} // Initialize HotelService with the provided repository
}

// CreateHotel creates a new hotel record in the repository.
func (s *HotelService) CreateHotel(ctx context.Context, hotel *models.Hotel) error {
	hotel.ID = uuid.New()            // Generate a new unique ID for the hotel
	hotel.CreatedAt = time.Now()     // Set the creation timestamp
	hotel.UpdatedAt = time.Now()     // Set the updated timestamp
	return s.repo.Create(ctx, hotel) // Save the hotel to the repository
}

// DeleteHotel removes a hotel record from the repository by its ID.
func (s *HotelService) DeleteHotel(ctx context.Context, id uuid.UUID) error {
	return s.repo.Delete(ctx, id) // Call the repository to delete the hotel
}

// GetHotelDetails retrieves hotel details by its ID.
func (s *HotelService) GetHotelDetails(ctx context.Context, id uuid.UUID) (*models.Hotel, error) {
	return s.repo.GetByID(ctx, id) // Fetch the hotel details from the repository
}

// ListOfficials retrieves the officials of a hotel by its ID.
func (s *HotelService) ListOfficials(ctx context.Context, id uuid.UUID) (*models.HotelOfficials, error) {
	hotel, err := s.repo.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}

	return &models.HotelOfficials{
		HotelID:         hotel.ID,
		OfficialName:    hotel.OfficialName,
		OfficialSurname: hotel.OfficialSurname,
	}, nil
}

================
File: logstash/pipeline/logstash.conf
================
# This configuration processes logs from Docker images starting with 'hotel-service'
input {
  beats {
    port => 5044
  }
}

filter {
  if [docker][image] =~ /^hotel-service/ {
    grok {
      match => { "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:log_level} %{GREEDYDATA:log_message}" }
    }
  }
}

output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "hotel-service-%{+YYYY.MM.dd}"
  }
}

================
File: pkg/logger/logger.go
================
package logger

import (
	"fmt"
	"log"
	"os"
	"time"
)

// Logger interface defines the methods for logging at different levels.
type Logger interface {
	Info(msg string, keysAndValues ...interface{})  // Log an informational message.
	Error(msg string, keysAndValues ...interface{}) // Log an error message.
	Fatal(msg string, keysAndValues ...interface{}) // Log a fatal message and exit the application.
}

// simpleLogger struct implements the Logger interface.
type simpleLogger struct {
	infoLogger  *log.Logger // Logger for info messages.
	errorLogger *log.Logger // Logger for error messages.
}

// New function creates a new instance of simpleLogger.
func New() Logger {
	return &simpleLogger{
		infoLogger:  log.New(os.Stdout, "", 0), // Initialize info logger to write to standard output.
		errorLogger: log.New(os.Stderr, "", 0), // Initialize error logger to write to standard error.
	}
}

// log method handles the actual logging logic for different levels.
func (l *simpleLogger) log(level, msg string, keysAndValues ...interface{}) {
	timestamp := time.Now().Format(time.RFC3339)             // Get the current timestamp.
	logMsg := fmt.Sprintf("%s %s %s", timestamp, level, msg) // Format the log message.
	if len(keysAndValues) > 0 {
		logMsg += fmt.Sprintf(" %v", keysAndValues) // Append any additional key-value pairs.
	}
	if level == "INFO" {
		l.infoLogger.Println(logMsg) // Log info messages.
	} else {
		l.errorLogger.Println(logMsg) // Log error and fatal messages.
	}
}

// Info method logs an informational message.
func (l *simpleLogger) Info(msg string, keysAndValues ...interface{}) {
	l.log("INFO", msg, keysAndValues...)
}

// Error method logs an error message.
func (l *simpleLogger) Error(msg string, keysAndValues ...interface{}) {
	l.log("ERROR", msg, keysAndValues...)
}

// Fatal method logs a fatal message and exits the application.
func (l *simpleLogger) Fatal(msg string, keysAndValues ...interface{}) {
	l.log("FATAL", msg, keysAndValues...)
	os.Exit(1) // Exit the application with a non-zero status.
}

================
File: README.md
================
hotel-service/
│
├── cmd/
│   └── api/
│       └── main.go
│
├── internal/
│   ├── api/
│   │   ├── handlers/
│   │   │   ├── hotel_handler.go
│   │   │   └── contact_handler.go
│   │   ├── middleware/
│   │   │   └── logging.go
│   │   └── router.go
│   │
│   ├── config/
│   │   └── config.go
│   │
│   ├── db/
│   │   ├── migrations/
│   │   │   ├── 000001_create_hotels_table.up.sql
│   │   │   ├── 000002_create_contacts_table.up.sql
│   │   └── db.go
│   │
│   ├── models/
│   │   ├── hotel.go
│   │   └── contact.go
│   │
│   ├── repository/
│   │   ├── hotel_repository.go
│   │   └── contact_repository.go
│   │
│   └── service/
│       ├── hotel_service.go
│       └── contact_service.go
│
├── pkg/
│   └── logger/
│       └── logger.go
│
├── tests/
│   ├── integration/
│   │   └── api_test.go
│   └── unit/
│       ├── handlers_test.go
│       ├── services_test.go
│       └── repositories_test.go
│
├── Dockerfile
├── Dockerfile.test
├── docker-compose.yml
├── go.mod
├── go.sum
└── README.md

================
File: tests/integration/rabbitmq_test.go
================
package integration

import (
	"encoding/json"
	"os"
	"testing"
	"time"

	"github.com/streadway/amqp"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/tfgoztok/hotel-service/internal/messaging"
)

func TestRabbitMQIntegration(t *testing.T) {
	rabbitMQURL := os.Getenv("RABBITMQ_URL")
	if rabbitMQURL == "" {
		rabbitMQURL = "amqp://guest:guest@localhost:5672/"
	}

	// Connect to RabbitMQ
	rabbitMQ, err := messaging.NewRabbitMQ(rabbitMQURL)
	require.NoError(t, err)
	defer rabbitMQ.Close()

	// Create a separate connection for consuming messages
	conn, err := amqp.Dial(rabbitMQURL)
	require.NoError(t, err)
	defer conn.Close()

	ch, err := conn.Channel()
	require.NoError(t, err)
	defer ch.Close()

	// Declare a test queue
	queueName := "test_queue"
	_, err = ch.QueueDeclare(
		queueName,
		false, // durable
		false, // auto-delete
		false, // exclusive
		false, // no-wait
		nil,   // arguments
	)
	require.NoError(t, err)

	// Publish a message
	testMessage := struct {
		ID string `json:"id"`
	}{
		ID: "integration-test-id",
	}
	err = rabbitMQ.PublishReportRequest(queueName, testMessage)
	require.NoError(t, err)

	// Consume the message
	msgs, err := ch.Consume(
		queueName,
		"",    // consumer
		true,  // auto-ack
		false, // exclusive
		false, // no-local
		false, // no-wait
		nil,   // args
	)
	require.NoError(t, err)

	// Wait for the message
	select {
	case msg := <-msgs:
		var receivedMessage struct {
			ID string `json:"id"`
		}
		err = json.Unmarshal(msg.Body, &receivedMessage)
		assert.NoError(t, err)
		assert.Equal(t, "integration-test-id", receivedMessage.ID)
	case <-time.After(5 * time.Second):
		t.Fatal("Timeout waiting for message")
	}

	// Clean up: delete the queue after the test
	_, err = ch.QueueDelete(queueName, false, false, false)
	require.NoError(t, err)
}

func TestNewRabbitMQ(t *testing.T) {
	rabbitMQURL := os.Getenv("RABBITMQ_URL")
	if rabbitMQURL == "" {
		rabbitMQURL = "amqp://guest:guest@localhost:5672/"
	}

	rabbitMQ, err := messaging.NewRabbitMQ(rabbitMQURL)
	assert.NoError(t, err)
	assert.NotNil(t, rabbitMQ)

	// Test that we can publish a message
	err = rabbitMQ.PublishReportRequest("test_queue", struct{}{})
	assert.NoError(t, err)

	rabbitMQ.Close()

	// Clean up: delete the queue after the test
	conn, err := amqp.Dial(rabbitMQURL)
	require.NoError(t, err)
	defer conn.Close()

	ch, err := conn.Channel()
	require.NoError(t, err)
	defer ch.Close()

	_, err = ch.QueueDelete("test_queue", false, false, false)
	require.NoError(t, err)
}

func TestNewRabbitMQError(t *testing.T) {
	_, err := messaging.NewRabbitMQ("invalid_url")
	assert.Error(t, err)
}

================
File: tests/unit/handlers_test.go
================
package unit

import (
	"testing"
)

func TestHandlers(t *testing.T) {
}

================
File: tests/unit/rabbitmq_test.go
================
// File: tests/unit/rabbitmq_test.go

package unit

import (
	"encoding/json"
	"testing"

	"github.com/stretchr/testify/assert"
)

// Mock RabbitMQ for unit tests
type MockRabbitMQ struct {
	publishedMessages [][]byte
}

func (m *MockRabbitMQ) PublishReportRequest(queueName string, reportRequest interface{}) error {
	body, _ := json.Marshal(reportRequest)
	m.publishedMessages = append(m.publishedMessages, body)
	return nil
}

func (m *MockRabbitMQ) Close() {}

// Unit test for PublishReportRequest
func TestPublishReportRequest(t *testing.T) {
	mock := &MockRabbitMQ{}

	reportRequest := struct {
		ID string `json:"id"`
	}{
		ID: "test-id",
	}

	err := mock.PublishReportRequest("test-queue", reportRequest)
	assert.NoError(t, err)
	assert.Len(t, mock.publishedMessages, 1)

	var receivedRequest struct {
		ID string `json:"id"`
	}
	err = json.Unmarshal(mock.publishedMessages[0], &receivedRequest)
	assert.NoError(t, err)
	assert.Equal(t, "test-id", receivedRequest.ID)
}

================
File: tests/unit/repositories_test.go
================
package unit

import (
	"context"
	"testing"
	"time"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/tfgoztok/hotel-service/internal/models"
	"github.com/tfgoztok/hotel-service/internal/repository"
)

func TestHotelRepositoryCreate(t *testing.T) {
	db, mock, err := sqlmock.New()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer db.Close()

	repo := repository.NewHotelRepository(db)

	hotel := &models.Hotel{
		ID:              uuid.New(),
		OfficialName:    "John",
		OfficialSurname: "Doe",
		CompanyTitle:    "Test Hotel",
		CreatedAt:       time.Now(),
		UpdatedAt:       time.Now(),
	}

	mock.ExpectExec("INSERT INTO hotels").
		WithArgs(hotel.ID, hotel.OfficialName, hotel.OfficialSurname, hotel.CompanyTitle, hotel.CreatedAt, hotel.UpdatedAt).
		WillReturnResult(sqlmock.NewResult(1, 1))

	err = repo.Create(context.Background(), hotel)

	assert.NoError(t, err)
	assert.NoError(t, mock.ExpectationsWereMet())
}

func TestHotelRepositoryDelete(t *testing.T) {
	db, mock, err := sqlmock.New()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer db.Close()

	repo := repository.NewHotelRepository(db)

	hotelID := uuid.New()

	mock.ExpectExec("DELETE FROM hotels").
		WithArgs(hotelID).
		WillReturnResult(sqlmock.NewResult(0, 1))

	err = repo.Delete(context.Background(), hotelID)

	assert.NoError(t, err)
	assert.NoError(t, mock.ExpectationsWereMet())
}

func TestHotelRepositoryGetByID(t *testing.T) {
	db, mock, err := sqlmock.New()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer db.Close()

	repo := repository.NewHotelRepository(db)

	hotelID := uuid.New()
	expectedHotel := &models.Hotel{
		ID:              hotelID,
		OfficialName:    "John",
		OfficialSurname: "Doe",
		CompanyTitle:    "Test Hotel",
		CreatedAt:       time.Now(),
		UpdatedAt:       time.Now(),
	}

	rows := sqlmock.NewRows([]string{"id", "official_name", "official_surname", "company_title", "created_at", "updated_at"}).
		AddRow(expectedHotel.ID, expectedHotel.OfficialName, expectedHotel.OfficialSurname, expectedHotel.CompanyTitle, expectedHotel.CreatedAt, expectedHotel.UpdatedAt)

	mock.ExpectQuery("SELECT (.+) FROM hotels").
		WithArgs(hotelID).
		WillReturnRows(rows)

	hotel, err := repo.GetByID(context.Background(), hotelID)

	assert.NoError(t, err)
	assert.Equal(t, expectedHotel, hotel)
	assert.NoError(t, mock.ExpectationsWereMet())
}

func TestContactRepositoryCreate(t *testing.T) {
	db, mock, err := sqlmock.New()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer db.Close()

	repo := repository.NewContactRepository(db)

	contact := &models.Contact{
		ID:        uuid.New(),
		HotelID:   uuid.New(),
		Type:      "email",
		Content:   "test@example.com",
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}

	mock.ExpectExec("INSERT INTO contacts").
		WithArgs(contact.ID, contact.HotelID, contact.Type, contact.Content, contact.CreatedAt, contact.UpdatedAt).
		WillReturnResult(sqlmock.NewResult(1, 1))

	err = repo.Create(context.Background(), contact)

	assert.NoError(t, err)
	assert.NoError(t, mock.ExpectationsWereMet())
}

func TestContactRepositoryDelete(t *testing.T) {
	db, mock, err := sqlmock.New()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer db.Close()

	repo := repository.NewContactRepository(db)

	contactID := uuid.New()

	mock.ExpectExec("DELETE FROM contacts").
		WithArgs(contactID).
		WillReturnResult(sqlmock.NewResult(0, 1))

	err = repo.Delete(context.Background(), contactID)

	assert.NoError(t, err)
	assert.NoError(t, mock.ExpectationsWereMet())
}

func TestContactRepositoryGetByHotelID(t *testing.T) {
	db, mock, err := sqlmock.New()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer db.Close()

	repo := repository.NewContactRepository(db)

	hotelID := uuid.New()
	expectedContacts := []*models.Contact{
		{
			ID:        uuid.New(),
			HotelID:   hotelID,
			Type:      "email",
			Content:   "test1@example.com",
			CreatedAt: time.Now(),
			UpdatedAt: time.Now(),
		},
		{
			ID:        uuid.New(),
			HotelID:   hotelID,
			Type:      "phone",
			Content:   "+1234567890",
			CreatedAt: time.Now(),
			UpdatedAt: time.Now(),
		},
	}

	rows := sqlmock.NewRows([]string{"id", "hotel_id", "type", "content", "created_at", "updated_at"})
	for _, contact := range expectedContacts {
		rows.AddRow(contact.ID, contact.HotelID, contact.Type, contact.Content, contact.CreatedAt, contact.UpdatedAt)
	}

	mock.ExpectQuery("SELECT (.+) FROM contacts").
		WithArgs(hotelID).
		WillReturnRows(rows)

	contacts, err := repo.GetByHotelID(context.Background(), hotelID)

	assert.NoError(t, err)
	assert.Equal(t, expectedContacts, contacts)
	assert.NoError(t, mock.ExpectationsWereMet())
}

================
File: tests/unit/services_test.go
================
package unit

import (
	"testing"
)

func TestServices(t *testing.T) {
}
